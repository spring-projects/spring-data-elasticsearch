<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
        "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="repositories">
    <title>Repositories</title>

    <section id="repositories.introduction">
        <title>Introduction</title>

        <para>Implementing a data access layer of an application has been
            cumbersome for quite a while. Too much boilerplate code had to be written.
            Domain classes were anemic and not designed in a real object oriented or
            domain driven manner.</para>

        <para>Using both of these technologies makes developers life a lot easier
            regarding rich domain model's persistence. Nevertheless the amount of
            boilerplate code to implement repositories especially is still quite high.
            So the goal of the repository abstraction of Spring Data is to reduce the
            effort to implement data access layers for various persistence stores
            significantly.</para>

        <para>The following chapters will introduce the core concepts and
            interfaces of Spring Data repositories in general for detailled
            information on the specific features of a particular store consult the
            later chapters of this document.</para>

        <note>
            <para>As this part of the documentation is pulled in from Spring Data
                Commons we have to decide for a particular module to be used as example.
                The configuration and code samples in this chapter are using the JPA
                module. Make sure you adapt e.g. the XML namespace declaration, types to
                be extended to the equivalents of the module you're actually
                using.</para>
        </note>
    </section>

    <section id="repositories.core-concepts">
        <title>Core concepts</title>

        <para>The central interface in Spring Data repository abstraction is
            <interfacename>Repository</interfacename> (probably not that much of a
            surprise). It is typeable to the domain class to manage as well as the id
            type of the domain class. This interface mainly acts as marker interface
            to capture the types to deal with and help us when discovering interfaces
            that extend this one. Beyond that there's
            <interfacename>CrudRepository</interfacename> which provides some
            sophisticated functionality around CRUD for the entity being
            managed.</para>

        <example id="repositories.repository">
            <title><interfacename>CrudRepository</interfacename> interface</title>

            <programlistingco>
                <areaspec>
                    <area coords="3" id="repository.save"/>

                    <area coords="5" id="repository.find-by-id"/>

                    <area coords="7" id="repository.find-all"/>

                    <area coords="11" id="repository.count"/>

                    <area coords="13" id="repository.delete"/>

                    <area coords="15" id="repository.exists"/>
                </areaspec>

                <programlisting language="java">public interface CrudRepository&lt;T, ID extends Serializable&gt;
                    extends Repository&lt;T, ID&gt; {

                    T save(T entity);

                    T findOne(ID primaryKey);

                    Iterable&lt;T&gt; findAll();

                    Long count();

                    void delete(T entity);

                    boolean exists(ID primaryKey);

                    // … more functionality omitted.
                    }</programlisting>

                <calloutlist>
                    <callout arearefs="repository.save">
                        <para>Saves the given entity.</para>
                    </callout>

                    <callout arch="" arearefs="repository.find-by-id">
                        <para>Returns the entity identified by the given id.</para>
                    </callout>

                    <callout arearefs="repository.find-all">
                        <para>Returns all entities.</para>
                    </callout>

                    <callout arearefs="repository.count">
                        <para>Returns the number of entities.</para>
                    </callout>

                    <callout arearefs="repository.delete">
                        <para>Deletes the given entity.</para>
                    </callout>

                    <callout arearefs="repository.exists">
                        <para>Returns whether an entity with the given id exists.</para>
                    </callout>
                </calloutlist>
            </programlistingco>
        </example>

        <para>Usually we will have persistence technology specific sub-interfaces
            to include additional technology specific methods. We will now ship
            implementations for a variety of Spring Data modules that implement this
            interface.</para>

        <para>On top of the <interfacename>CrudRepository</interfacename> there is
            a <interfacename>PagingAndSortingRepository</interfacename> abstraction
            that adds additional methods to ease paginated access to entities:</para>

        <example>
            <title>PagingAndSortingRepository</title>

            <programlisting language="java">public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt; extends CrudRepository&lt;T, ID&gt; {

                Iterable&lt;T&gt; findAll(Sort sort);

                Page&lt;T&gt; findAll(Pageable pageable);
                }</programlisting>
        </example>

        <para>Accessing the second page of <classname>User</classname> by a page
            size of 20 you could simply do something like this:</para>

        <programlisting language="java">PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean
            Page&lt;User&gt; users = repository.findAll(new PageRequest(1, 20));</programlisting>
    </section>

    <section id="repositories.query-methods">
        <title>Query methods</title>

        <para>Next to standard CRUD functionality repositories are usually queries
            on the underlying datastore. With Spring Data declaring those queries
            becomes a four-step process:</para>

        <orderedlist>
            <listitem>
                <para>Declare an interface extending
                    <interfacename>Repository</interfacename> or one of its sub-interfaces
                    and type it to the domain class it shall handle.</para>

                <programlisting language="java">public interface PersonRepository extends Repository&lt;User, Long&gt; { … }</programlisting>
            </listitem>

            <listitem>
                <para>Declare query methods on the interface.</para>

                <programlisting language="java">List&lt;Person&gt; findByLastname(String lastname);</programlisting>
            </listitem>

            <listitem>
                <para>Setup Spring to create proxy instances for those
                    interfaces.</para>

                <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                    &lt;beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xmlns="http://www.springframework.org/schema/data/jpa"
                    xsi:schemaLocation="http://www.springframework.org/schema/beans
                    http://www.springframework.org/schema/beans/spring-beans.xsd
                    http://www.springframework.org/schema/data/jpa
                    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

                    &lt;repositories base-package="com.acme.repositories" /&gt;

                    &lt;/beans&gt;</programlisting>

                <note>
                    <para>Note that we use the JPA namespace here just by example. If
                        you're using the repository abstraction for any other store you need
                        to change this to the appropriate namespace declaration of your
                        store module which should be exchanging <code>jpa</code> in favor of
                        e.g. <code>mongodb</code>.</para>
                </note>
            </listitem>

            <listitem>
                <para>Get the repository instance injected and use it.</para>

                <programlisting language="java">public class SomeClient {

                    @Autowired
                    private PersonRepository repository;

                    public void doSomething() {
                    List&lt;Person&gt; persons = repository.findByLastname("Matthews");
                    }</programlisting>
            </listitem>
        </orderedlist>

        <para>At this stage we barely scratched the surface of what's possible
            with the repositories but the general approach should be clear. Let's go
            through each of these steps and figure out details and various options
            that you have at each stage.</para>

        <section id="repositories.definition">
            <title>Defining repository interfaces</title>

            <para>As a very first step you define a domain class specific repository
                interface. It's got to extend <interfacename>Repository</interfacename>
                and be typed to the domain class and an ID type. If you want to expose
                CRUD methods for that domain type, extend
                <interfacename>CrudRepository</interfacename> instead of
                <interfacename>Repository</interfacename>.</para>

            <section id="repositories.definition-tuning">
                <title>Fine tuning repository definition</title>

                <para>Usually you will have your repository interface extend
                    <interfacename>Repository</interfacename>,
                    <interfacename>CrudRepository</interfacename> or
                    <interfacename>PagingAndSortingRepository</interfacename>. If you
                    don't like extending Spring Data interfaces at all you can also
                    annotate your repository interface with
                    <interfacename>@RepositoryDefinition</interfacename>. Extending
                    <interfacename>CrudRepository</interfacename> will expose a complete
                    set of methods to manipulate your entities. If you would rather be
                    selective about the methods being exposed, simply copy the ones you
                    want to expose from <interfacename>CrudRepository</interfacename> into
                    your domain repository.</para>

                <example>
                    <title>Selectively exposing CRUD methods</title>

                    <programlisting language="java">interface MyBaseRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; {
                        T findOne(ID id);
                        T save(T entity);
                        }

                        interface UserRepository extends MyBaseRepository&lt;User, Long&gt; {

                        User findByEmailAddress(EmailAddress emailAddress);
                        }</programlisting>
                </example>

                <para>In the first step we define a common base interface for all our
                    domain repositories and expose <methodname>findOne(…)</methodname> as
                    well as <methodname>save(…)</methodname>.These methods will be routed
                    into the base repository implementation of the store of your choice
                    because they are matching the method signatures in
                    <interfacename>CrudRepository</interfacename>. So our
                    <interfacename>UserRepository</interfacename> will now be able to save
                    users, find single ones by id as well as triggering a query to find
                    <interfacename>User</interfacename>s by their email address.</para>
            </section>
        </section>

        <section id="repositories.query-methods.details">
            <title>Defining query methods</title>

            <section id="repositories.query-methods.query-lookup-strategies">
                <title>Query lookup strategies</title>

                <para>The next thing we have to discuss is the definition of query
                    methods. There are two main ways that the repository proxy is able to
                    come up with the store specific query from the method name. The first
                    option is to derive the query from the method name directly, the
                    second is using some kind of additionally created query. What detailed
                    options are available pretty much depends on the actual store,
                    however, there's got to be some algorithm that decides what actual
                    query is created.</para>

                <para>There are three strategies available for the repository
                    infrastructure to resolve the query. The strategy to be used can be
                    configured at the namespace through the
                    <code>query-lookup-strategy</code> attribute. However, It might be the
                    case that some of the strategies are not supported for specific
                    datastores. Here are your options:</para>

                <simplesect>
                    <title>CREATE</title>

                    <para>This strategy will try to construct a store specific query
                        from the query method's name. The general approach is to remove a
                        given set of well-known prefixes from the method name and parse the
                        rest of the method. Read more about query construction in <xref
                                linkend="repositories.query-methods.query-creation"/>.</para>
                </simplesect>

                <simplesect>
                    <title>USE_DECLARED_QUERY</title>

                    <para>This strategy tries to find a declared query which will be
                        used for execution first. The query could be defined by an
                        annotation somewhere or declared by other means. Please consult the
                        documentation of the specific store to find out what options are
                        available for that store. If the repository infrastructure does not
                        find a declared query for the method at bootstrap time it will
                        fail.</para>
                </simplesect>

                <simplesect>
                    <title>CREATE_IF_NOT_FOUND (default)</title>

                    <para>This strategy is actually a combination of <code>CREATE</code>
                        and <code>USE_DECLARED_QUERY</code>. It will try to lookup a
                        declared query first but create a custom method name based query if
                        no declared query was found. This is the default lookup strategy and
                        thus will be used if you don't configure anything explicitly. It
                        allows quick query definition by method names but also custom tuning
                        of these queries by introducing declared queries as needed.</para>
                </simplesect>
            </section>

            <section id="repositories.query-methods.query-creation">
                <title>Query creation</title>

                <para>The query builder mechanism built into Spring Data repository
                    infrastructure is useful to build constraining queries over entities
                    of the repository. We will strip the prefixes <code>findBy</code>,
                    <code>find</code>, <code>readBy</code>, <code>read</code>,
                    <code>getBy</code> as well as <code>get</code> from the method and
                    start parsing the rest of it. At a very basic level you can define
                    conditions on entity properties and concatenate them with
                    <code>AND</code> and <code>OR</code>.</para>

                <example>
                    <title>Query creation from method names</title>

                    <para><programlisting language="java">public interface PersonRepository extends Repository&lt;User, Long&gt; {

                        List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);
                        }</programlisting></para>
                </example>

                <para>The actual result of parsing that method will of course depend
                    on the persistence store we create the query for, however, there are
                    some general things to notice. The expressions are usually property
                    traversals combined with operators that can be concatenated. As you
                    can see in the example you can combine property expressions with And
                    and Or. Beyond that you also get support for various operators like
                    <literal>Between</literal>, <literal>LessThan</literal>,
                    <literal>GreaterThan</literal>, <literal>Like</literal> for the
                    property expressions. As the operators supported can vary from
                    datastore to datastore please consult the according part of the
                    reference documentation.</para>

                <section id="repositories.query-methods.property-expressions">
                    <title>Property expressions</title>

                    <para>Property expressions can just refer to a direct property of
                        the managed entity (as you just saw in the example above). On query
                        creation time we already make sure that the parsed property is at a
                        property of the managed domain class. However, you can also define
                        constraints by traversing nested properties. Assume
                        <classname>Person</classname>s have <classname>Address</classname>es
                        with <classname>ZipCode</classname>s. In that case a method name
                        of</para>

                    <programlisting language="java">List&lt;Person&gt; findByAddressZipCode(ZipCode zipCode);</programlisting>

                    <para>will create the property traversal
                        <code>x.address.zipCode</code>. The resolution algorithm starts with
                        interpreting the entire part (<literal>AddressZipCode</literal>) as
                        property and checks the domain class for a property with that name
                        (uncapitalized). If it succeeds it just uses that. If not it starts
                        splitting up the source at the camel case parts from the right side
                        into a head and a tail and tries to find the according property,
                        e.g. <literal>AddressZip</literal> and <literal>Code</literal>. If
                        we find a property with that head we take the tail and continue
                        building the tree down from there. As in our case the first split
                        does not match we move the split point to the left
                        (<literal>Address</literal>, <literal>ZipCode</literal>).</para>

                    <para>Although this should work for most cases, there might be cases
                        where the algorithm could select the wrong property. Suppose our
                        <classname>Person</classname> class has an <code>addressZip</code>
                        property as well. Then our algorithm would match in the first split
                        round already and essentially choose the wrong property and finally
                        fail (as the type of <classname>addressZip</classname> probably has
                        no code property). To resolve this ambiguity you can use
                        <literal>_</literal> inside your method name to manually define
                        traversal points. So our method name would end up like so:</para>

                    <programlisting language="java">List&lt;Person&gt; findByAddress_ZipCode(ZipCode zipCode);
                    </programlisting>
                </section>
            </section>

            <section id="repositories.special-parameters">
                <title>Special parameter handling</title>

                <para>To hand parameters to your query you simply define method
                    parameters as already seen in the examples above. Besides that we will
                    recognizes certain specific types to apply pagination and sorting to
                    your queries dynamically.</para>

                <example>
                    <title>Using Pageable and Sort in query methods</title>

                    <programlisting>Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);

                        List&lt;User&gt; findByLastname(String lastname, Sort sort);

                        List&lt;User&gt; findByLastname(String lastname, Pageable pageable);</programlisting>
                </example>

                <para>The first method allows you to pass a <code>Pageable</code>
                    instance to the query method to dynamically add paging to your
                    statically defined query. <code>Sorting</code> options are handed via
                    the <interfacename>Pageable</interfacename> instance too. If you only
                    need sorting, simply add a <code>Sort</code> parameter to your method.
                    As you also can see, simply returning a
                    <interfacename>List</interfacename> is possible as well. We will then
                    not retrieve the additional metadata required to build the actual
                    <interfacename>Page</interfacename> instance but rather simply
                    restrict the query to lookup only the given range of entities.</para>

                <note>
                    <para>To find out how many pages you get for a query entirely we
                        have to trigger an additional count query. This will be derived from
                        the query you actually trigger by default.</para>
                </note>
            </section>
        </section>

        <section id="repositories.create-instances">
            <title>Creating repository instances</title>

            <para>So now the question is how to create instances and bean
                definitions for the repository interfaces defined.</para>

            <section id="repositories.create-instances.spring">
                <title>XML Configuration</title>

                <para>The easiest way to do so is by using the Spring namespace that
                    is shipped with each Spring Data module that supports the repository
                    mechanism. Each of those includes a repositories element that allows
                    you to simply define a base package that Spring will scan for
                    you.</para>

                <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                    &lt;beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xmlns="http://www.springframework.org/schema/data/jpa"
                    xsi:schemaLocation="http://www.springframework.org/schema/beans
                    http://www.springframework.org/schema/beans/spring-beans.xsd
                    http://www.springframework.org/schema/data/jpa
                    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

                    &lt;repositories base-package="com.acme.repositories" /&gt;

                    &lt;/beans:beans&gt;</programlisting>

                <para>In this case we instruct Spring to scan
                    <package>com.acme.repositories</package> and all its sub packages for
                    interfaces extending <interfacename>Repository</interfacename> or one
                    of its sub-interfaces. For each interface found it will register the
                    persistence technology specific
                    <interfacename>FactoryBean</interfacename> to create the according
                    proxies that handle invocations of the query methods. Each of these
                    beans will be registered under a bean name that is derived from the
                    interface name, so an interface of
                    <interfacename>UserRepository</interfacename> would be registered
                    under <code>userRepository</code>. The <code>base-package</code>
                    attribute allows the use of wildcards, so that you can have a pattern
                    of scanned packages.</para>

                <simplesect>
                    <title>Using filters</title>

                    <para>By default we will pick up every interface extending the
                        persistence technology specific
                        <interfacename>Repository</interfacename> sub-interface located
                        underneath the configured base package and create a bean instance
                        for it. However, you might want finer grained control over which
                        interfaces bean instances get created for. To do this we support the
                        use of <code>&lt;include-filter /&gt;</code> and
                        <code>&lt;exclude-filter /&gt;</code> elements inside
                        <code>&lt;repositories /&gt;</code>. The semantics are exactly
                        equivalent to the elements in Spring's context namespace. For
                        details see <ulink
                                url="http://static.springsource.org/spring/docs/2.5.x/reference/beans.html#beans-scanning-filters"
                                vendor="">Spring reference documentation</ulink> on these
                        elements.</para>

                    <para>E.g. to exclude certain interfaces from instantiation as
                        repository, you could use the following configuration:</para>

                    <example>
                        <title>Using exclude-filter element</title>

                        <programlisting language="xml">&lt;repositories base-package="com.acme.repositories"&gt;
                            &lt;context:exclude-filter type="regex" expression=".*SomeRepository" /&gt;
                            &lt;/repositories&gt;</programlisting>

                        <para>This would exclude all interfaces ending in
                            <interfacename>SomeRepository</interfacename> from being
                            instantiated.</para>
                    </example>
                </simplesect>
            </section>

            <section id="repositories.create-instances.java-config">
                <title>JavaConfig</title>

                <para>The repository infrastructure can also be triggered using a
                    store-specific
                    <interfacename>@Enable${store}Repositories</interfacename> annotation
                    on a JavaConfig class. For an introduction into Java based
                    configuration of the Spring container please have a look at the
                    reference documentation.<footnote>
                        <para>JavaConfig in the Spring reference documentation - <ulink
                                url="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java"/></para>
                    </footnote></para>

                <para>A sample configuration to enable Spring Data repositories would
                    look something like this.</para>

                <example>
                    <title>Sample annotation based repository configuration</title>

                    <programlisting>@Configuration
                        @EnableJpaRepositories("com.acme.repositories")
                        class ApplicationConfiguration {

                        @Bean
                        public EntityManagerFactory entityManagerFactory() {
                        // …
                        }
                        }</programlisting>
                </example>

                <para>Note that the sample uses the JPA specific annotation which
                    would have to be exchanged dependingon which store module you actually
                    use. The same applies to the definition of the
                    <interfacename>EntityManagerFactory</interfacename> bean. Please
                    consult the sections covering the store-specific configuration.</para>
            </section>

            <section id="repositories.create-instances.standalone">
                <title>Standalone usage</title>

                <para>You can also use the repository infrastructure outside of a
                    Spring container usage. You will still need to have some of the Spring
                    libraries on your classpath but you can generally setup repositories
                    programmatically as well. The Spring Data modules providing repository
                    support ship a persistence technology specific
                    <classname>RepositoryFactory</classname> that can be used as
                    follows:</para>

                <example>
                    <title>Standalone usage of repository factory</title>

                    <programlisting language="java">RepositoryFactorySupport factory = … // Instantiate factory here
                        UserRepository repository = factory.getRepository(UserRepository.class);</programlisting>
                </example>
            </section>
        </section>
    </section>

    <section id="repositories.custom-implementations">
        <title>Custom implementations</title>

        <section id="repositories.single-repository-behaviour">
            <title>Adding behaviour to single repositories</title>

            <para>Often it is necessary to provide a custom implementation for a few
                repository methods. Spring Data repositories easily allow you to provide
                custom repository code and integrate it with generic CRUD abstraction
                and query method functionality. To enrich a repository with custom
                functionality you have to define an interface and an implementation for
                that functionality first and let the repository interface you provided
                so far extend that custom interface.</para>

            <example>
                <title>Interface for custom repository functionality</title>

                <programlisting language="java">interface UserRepositoryCustom {

                    public void someCustomMethod(User user);
                    }</programlisting>
            </example>

            <example>
                <title>Implementation of custom repository functionality</title>

                <para><programlisting language="java">class UserRepositoryImpl implements UserRepositoryCustom {

                    public void someCustomMethod(User user) {
                    // Your custom implementation
                    }
                    }</programlisting>Note that the implementation itself does not depend on
                    Spring Data and can be a regular Spring bean. So you can use standard
                    dependency injection behaviour to inject references to other beans,
                    take part in aspects and so on.</para>
            </example>

            <example>
                <title>Changes to the your basic repository interface</title>

                <para><programlisting language="java">public interface UserRepository extends CrudRepository&lt;User, Long&gt;, UserRepositoryCustom {

                    // Declare query methods here
                    }</programlisting>Let your standard repository interface extend the custom
                    one. This makes CRUD and custom functionality available to
                    clients.</para>
            </example>

            <simplesect>
                <title>Configuration</title>

                <para>If you use namespace configuration the repository infrastructure
                    tries to autodetect custom implementations by looking up classes in
                    the package we found a repository using the naming conventions
                    appending the namespace element's attribute
                    <code>repository-impl-postfix</code> to the classname. This suffix
                    defaults to <code>Impl</code>.</para>

                <example>
                    <title>Configuration example</title>

                    <para><programlisting language="xml">&lt;repositories base-package="com.acme.repository" /&gt;

                        &lt;repositories base-package="com.acme.repository" repository-impl-postfix="FooBar" /&gt;</programlisting></para>
                </example>

                <para>The first configuration example will try to lookup a class
                    <classname>com.acme.repository.UserRepositoryImpl</classname> to act
                    as custom repository implementation, where the second example will try
                    to lookup
                    <classname>com.acme.repository.UserRepositoryFooBar</classname>.</para>
            </simplesect>

            <simplesect>
                <title>Manual wiring</title>

                <para>The approach above works perfectly well if your custom
                    implementation uses annotation based configuration and autowiring
                    entirely as it will be treated as any other Spring bean. If your
                    custom implementation bean needs some special wiring you simply
                    declare the bean and name it after the conventions just described. We
                    will then pick up the custom bean by name rather than creating an
                    instance.</para>

                <example>
                    <title>Manual wiring of custom implementations (I)</title>

                    <programlisting language="xml">&lt;repositories base-package="com.acme.repository" /&gt;

                        &lt;beans:bean id="userRepositoryImpl" class="…"&gt;
                        &lt;!-- further configuration --&gt;
                        &lt;/beans:bean&gt;</programlisting>
                </example>
            </simplesect>
        </section>

        <section id="repositories.custom-behaviour-for-all-repositories">
            <title>Adding custom behaviour to all repositories</title>

            <para>In other cases you might want to add a single method to all of
                your repository interfaces. So the approach just shown is not feasible.
                The first step to achieve this is adding and intermediate interface to
                declare the shared behaviour</para>

            <example>
                <title>An interface declaring custom shared behaviour</title>

                <para><programlisting language="java">
                    public interface MyRepository&lt;T, ID extends Serializable&gt;
                    extends JpaRepository&lt;T, ID&gt; {

                    void sharedCustomMethod(ID id);
                    }</programlisting></para>
            </example>

            <para>Now your individual repository interfaces will extend this
                intermediate interface instead of the
                <interfacename>Repository</interfacename> interface to include the
                functionality declared. The second step is to create an implementation
                of this interface that extends the persistence technology specific
                repository base class which will then act as a custom base class for the
                repository proxies.</para>

            <note>
                <para>The default behaviour of the Spring <code>&lt;repositories
                    /&gt;</code> namespace is to provide an implementation for all
                    interfaces that fall under the <code>base-package</code>. This means
                    that if left in it's current state, an implementation instance of
                    <interfacename>MyRepository</interfacename> will be created by Spring.
                    This is of course not desired as it is just supposed to act as an
                    intermediary between <interfacename>Repository</interfacename> and the
                    actual repository interfaces you want to define for each entity. To
                    exclude an interface extending
                    <interfacename>Repository</interfacename> from being instantiated as a
                    repository instance it can either be annotate it with
                    <interfacename>@NoRepositoryBean</interfacename> or moved out side of
                    the configured <code>base-package</code>.</para>
            </note>

            <example>
                <title>Custom repository base class</title>

                <programlisting language="java">
                    public class MyRepositoryImpl&lt;T, ID extends Serializable&gt;
                    extends SimpleJpaRepository&lt;T, ID&gt; implements MyRepository&lt;T, ID&gt; {

                    private EntityManager entityManager;

                    // There are two constructors to choose from, either can be used.
                    public MyRepositoryImpl(Class&lt;T&gt; domainClass, EntityManager entityManager) {
                    super(domainClass, entityManager);

                    // This is the recommended method for accessing inherited class dependencies.
                    this.entityManager = entityManager;
                    }

                    public void sharedCustomMethod(ID id) {
                    // implementation goes here
                    }
                    }</programlisting>
            </example>

            <para>The last step is to create a custom repository factory to replace
                the default <classname>RepositoryFactoryBean</classname> that will in
                turn produce a custom <classname>RepositoryFactory</classname>. The new
                repository factory will then provide your
                <classname>MyRepositoryImpl</classname> as the implementation of any
                interfaces that extend the <interfacename>Repository</interfacename>
                interface, replacing the <classname>SimpleJpaRepository</classname>
                implementation you just extended.</para>

            <example>
                <title>Custom repository factory bean</title>

                <programlisting language="java">
                    public class MyRepositoryFactoryBean&lt;R extends JpaRepository&lt;T, I&gt;, T, I extends Serializable&gt;
                    extends JpaRepositoryFactoryBean&lt;R, T, I&gt; {

                    protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

                    return new MyRepositoryFactory(entityManager);
                    }

                    private static class MyRepositoryFactory&lt;T, I extends Serializable&gt; extends JpaRepositoryFactory {

                    private EntityManager entityManager;

                    public MyRepositoryFactory(EntityManager entityManager) {
                    super(entityManager);

                    this.entityManager = entityManager;
                    }

                    protected Object getTargetRepository(RepositoryMetadata metadata) {

                    return new MyRepositoryImpl&lt;T, I&gt;((Class&lt;T&gt;) metadata.getDomainClass(), entityManager);
                    }

                    protected Class&lt;?&gt; getRepositoryBaseClass(RepositoryMetadata metadata) {

                    // The RepositoryMetadata can be safely ignored, it is used by the JpaRepositoryFactory
                    //to check for QueryDslJpaRepository's which is out of scope.
                    return MyRepository.class;
                    }
                    }
                    }</programlisting>
            </example>

            <para>Finally you can either declare beans of the custom factory
                directly or use the <code>factory-class</code> attribute of the Spring
                namespace to tell the repository infrastructure to use your custom
                factory implementation.</para>

            <example>
                <title>Using the custom factory with the namespace</title>

                <programlisting language="xml">&lt;repositories base-package="com.acme.repository"
                    factory-class="com.acme.MyRepositoryFactoryBean" /&gt;</programlisting>
            </example>
        </section>
    </section>

    <section>
        <title>Extensions</title>

        <para>This chapter documents a set of Spring Data extensions that enable
            Spring Data usage in a variety of contexts. Currently most of the
            integration is targeted towards Spring MVC.</para>

        <section id="web-domain-class-binding">
            <title>Domain class web binding for Spring MVC</title>

            <para>Given you are developing a Spring MVC web applications you
                typically have to resolve domain class ids from URLs. By default it's
                your task to transform that request parameter or URL part into the
                domain class to hand it layers below then or execute business logic on
                the entities directly. This should look something like this:</para>

            <programlisting language="java">@Controller
                @RequestMapping("/users")
                public class UserController {

                private final UserRepository userRepository;

                public UserController(UserRepository userRepository) {
                userRepository = userRepository;
                }

                @RequestMapping("/{id}")
                public String showUserForm(@PathVariable("id") Long id, Model model) {

                // Do null check for id
                User user = userRepository.findOne(id);
                // Do null check for user
                // Populate model
                return "user";
                }
                }</programlisting>

            <para>First you pretty much have to declare a repository dependency for
                each controller to lookup the entity managed by the controller or
                repository respectively. Beyond that looking up the entity is
                boilerplate as well as it's always a <methodname>findOne(…)</methodname>
                call. Fortunately Spring provides means to register custom converting
                components that allow conversion between a <classname>String</classname>
                value to an arbitrary type.</para>

            <simplesect>
                <title>PropertyEditors</title>

                <para>For versions up to Spring 3.0 simple Java
                    <interfacename>PropertyEditor</interfacename>s had to be used. Thus,
                    we offer a <classname>DomainClassPropertyEditorRegistrar</classname>,
                    that will look up all Spring Data repositories registered in the
                    <interfacename>ApplicationContext</interfacename> and register a
                    custom <interfacename>PropertyEditor</interfacename> for the managed
                    domain class</para>

                <programlisting language="xml">&lt;bean class="….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt;
                    &lt;property name="webBindingInitializer"&gt;
                    &lt;bean class="….web.bind.support.ConfigurableWebBindingInitializer"&gt;
                    &lt;property name="propertyEditorRegistrars"&gt;
                    &lt;bean class="org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar" /&gt;
                    &lt;/property&gt;
                    &lt;/bean&gt;
                    &lt;/property&gt;
                    &lt;/bean&gt;</programlisting>

                <para>If you have configured Spring MVC like this you can turn your
                    controller into the following that reduces a lot of the clutter and
                    boilerplate.</para>

                <programlisting lang="" language="java">@Controller
                    @RequestMapping("/users")
                    public class UserController {

                    @RequestMapping("/{id}")
                    public String showUserForm(@PathVariable("id") User user, Model model) {

                    // Do null check for user
                    // Populate model
                    return "userForm";
                    }
                    }</programlisting>
            </simplesect>

            <simplesect>
                <title>ConversionService</title>

                <para>As of Spring 3.0 the
                    <interfacename>PropertyEditor</interfacename> support is superseeded
                    by a new conversion infrstructure that leaves all the drawbacks of
                    <interfacename>PropertyEditor</interfacename>s behind and uses a
                    stateless X to Y conversion approach. We now ship with a
                    <classname>DomainClassConverter</classname> that pretty much mimics
                    the behaviour of
                    <classname>DomainClassPropertyEditorRegistrar</classname>. To register
                    the converter you have to declare
                    <classname>ConversionServiceFactoryBean</classname>, register the
                    converter and tell the Spring MVC namespace to use the configured
                    conversion service:</para>

                <programlisting language="xml">&lt;mvc:annotation-driven conversion-service="conversionService" /&gt;

                    &lt;bean id="conversionService" class="….context.support.ConversionServiceFactoryBean"&gt;
                    &lt;property name="converters"&gt;
                    &lt;list&gt;
                    &lt;bean class="org.springframework.data.repository.support.DomainClassConverter"&gt;
                    &lt;constructor-arg ref="conversionService" /&gt;
                    &lt;/bean&gt;
                    &lt;/list&gt;
                    &lt;/property&gt;
                    &lt;/bean&gt;</programlisting>
            </simplesect>
        </section>

        <section id="web-pagination">
            <title>Web pagination</title>

            <programlisting lang="" language="java">@Controller
                @RequestMapping("/users")
                public class UserController {

                // DI code omitted

                @RequestMapping
                public String showUsers(Model model, HttpServletRequest request) {

                int page = Integer.parseInt(request.getParameter("page"));
                int pageSize = Integer.parseInt(request.getParameter("pageSize"));
                model.addAttribute("users", userService.getUsers(pageable));
                return "users";
                }
                }</programlisting>

            <para>As you can see the naive approach requires the method to contain
                an <interfacename>HttpServletRequest</interfacename> parameter that has
                to be parsed manually. We even omitted an appropriate failure handling
                which would make the code even more verbose. The bottom line is that the
                controller actually shouldn't have to handle the functionality of
                extracting pagination information from the request. So we include a
                <classname>PageableArgumentResolver</classname> that will do the work
                for you.</para>

            <programlisting language="xml">&lt;bean class="….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt;
                &lt;property name="customArgumentResolvers"&gt;
                &lt;list&gt;
                &lt;bean class="org.springframework.data.web.PageableArgumentResolver" /&gt;
                &lt;/list&gt;
                &lt;/property&gt;
                &lt;/bean&gt;</programlisting>

            <para>This configuration allows you to simplify controllers down to
                something like this:</para>

            <programlisting lang="" language="java">@Controller
                @RequestMapping("/users")
                public class UserController {

                @RequestMapping
                public String showUsers(Model model, Pageable pageable) {

                model.addAttribute("users", userDao.readAll(pageable));
                return "users";
                }
                }</programlisting>

            <para>The <classname>PageableArgumentResolver</classname> will
                automatically resolve request parameters to build a
                <classname>PageRequest</classname> instance. By default it will expect
                the following structure for the request parameters:</para>

            <table>
                <title>Request parameters evaluated by
                    <classname>PageableArgumentResolver</classname></title>

                <tgroup cols="2">
                    <colspec colwidth="1*"/>

                    <colspec colwidth="2*"/>

                    <tbody>
                        <row>
                            <entry><code>page</code></entry>

                            <entry>The page you want to retrieve</entry>
                        </row>

                        <row>
                            <entry><code>page.size</code></entry>

                            <entry>The size of the page you want to retrieve</entry>
                        </row>

                        <row>
                            <entry><code>page.sort</code></entry>

                            <entry>The property that should be sorted by</entry>
                        </row>

                        <row>
                            <entry><code>page.sort.dir</code></entry>

                            <entry>The direction that should be used for sorting</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <para>In case you need multiple <interfacename>Pageable</interfacename>s
                to be resolved from the request (for multiple tables e.g.) you can use
                Spring's <interfacename>@Qualifier</interfacename> annotation to
                distinguish one from another. The request parameters then have to be
                prefixed with <code>${qualifier}_</code>. So a method signature like
                this:</para>

            <programlisting lang="" language="java">public String showUsers(Model model,
                @Qualifier("foo") Pageable first,
                @Qualifier("bar") Pageable second) { … }
            </programlisting>

            <para>you'd have to populate <code>foo_page</code> and
                <code>bar_page</code> and the according subproperties.</para>

            <simplesect>
                <title>Defaulting</title>

                <para>The <classname>PageableArgumentResolver</classname> will use a
                    <classname>PageRequest</classname> with the first page and a page size
                    of 10 by default and will use that in case it can't resolve a
                    <classname>PageRequest</classname> from the request (because of
                    missing parameters e.g.). You can configure a global default on the
                    bean declaration directly. In case you might need controller method
                    specific defaults for the <interfacename>Pageable</interfacename>
                    simply annotate the method parameter with
                    <interfacename>@PageableDefaults</interfacename> and specify page and
                    page size as annotation attributes:</para>

                <programlisting lang="" language="java">public String showUsers(Model model,
                    @PageableDefaults(pageNumber = 0, value = 30) Pageable pageable) { … }
                </programlisting>
            </simplesect>
        </section>

        <section>
            <title>Repository populators</title>

            <para>If you have been working with the JDBC module of Spring you're
                probably familiar with the support to populate a DataSource using SQL
                scripts. A similar abstraction is available on the repositories level
                although we don't use SQL as data definition language as we need to be
                store independent of course. Thus the populators support XML (through
                Spring's OXM abstraction) and JSON (through Jackson) to define data for
                the repositories to be populated with.</para>

            <para>Assume you have a file <filename>data.json</filename> with the
                following content:</para>

            <example>
                <title>Data defined in JSON</title>

                <programlisting>[ { "_class" : "com.acme.Person",
                    "firstname" : "Dave",
                    "lastname" : "Matthews" },
                    { "_class" : "com.acme.Person",
                    "firstname" : "Carter",
                    "lastname" : "Beauford" } ]</programlisting>
            </example>

            <para>You can easily populate you repositories by using the populator
                elements of the repository namespace provided in Spring Data Commons. To
                get the just shown data be populated to your
                <interfacename>PersonRepository</interfacename> all you need to do is
                the following:</para>

            <example>
                <title>Declaring a Jackson repository populator</title>

                <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                    &lt;beans xmlns="http://www.springframework.org/schema/beans"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xmlns:repository="http://www.springframework.org/schema/data/repository"
                    xsi:schemaLocation="http://www.springframework.org/schema/beans
                    http://www.springframework.org/schema/beans/spring-beans.xsd
                    http://www.springframework.org/schema/data/repository
                    http://www.springframework.org/schema/data/repository/spring-repository.xsd"&gt;

                    &lt;repository:jackson-populator location="classpath:data.json" /&gt;

                    &lt;/beans&gt;</programlisting>
            </example>

            <para>This declaration causes the data.json file being read,
                deserialized by a Jackson <classname>ObjectMapper</classname>. The type
                the JSON object will be unmarshalled to will be determined by inspecting
                the <code>_class</code> attribute of the JSON document. We will
                eventually select the appropriate repository being able to handle the
                object just deserialized.</para>

            <para>To rather use XML to define the repositories shall be populated
                with you can use the unmarshaller-populator you hand one of the
                marshaller options Spring OXM provides you with.</para>

            <example>
                <title>Declaring an unmarshalling repository populator (using
                    JAXB)</title>

                <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
                    &lt;beans xmlns="http://www.springframework.org/schema/beans"
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                    xmlns:repository="http://www.springframework.org/schema/data/repository"
                    xmlns:oxm="http://www.springframework.org/schema/oxm"
                    xsi:schemaLocation="http://www.springframework.org/schema/beans
                    http://www.springframework.org/schema/beans/spring-beans.xsd
                    http://www.springframework.org/schema/data/repository
                    http://www.springframework.org/schema/data/repository/spring-repository.xsd
                    http://www.springframework.org/schema/oxm
                    http://www.springframework.org/schema/oxm/spring-oxm.xsd"&gt;

                    &lt;repository:unmarshaller-populator location="classpath:data.json" unmarshaller-ref="unmarshaller" /&gt;

                    &lt;oxm:jaxb2-marshaller contextPath="com.acme" /&gt;

                    &lt;/beans&gt;</programlisting>
            </example>
        </section>
    </section>
</chapter>